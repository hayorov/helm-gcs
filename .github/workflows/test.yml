name: test

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - 'pkg/**'
      - 'cmd/**'
      - 'go.mod'
      - 'go.sum'
      - '.github/workflows/test.yml'
      - '.golangci.yml'

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          ignore-unfixed: true
          format: "sarif"
          output: "trivy-results.sarif"
          severity: "CRITICAL"
      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: "trivy-results.sarif"
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25"
      - name: golangci-lint
        uses: golangci/golangci-lint-action@v7
      - name: Check code formatting
        run: |
          GO_FILES=$(find . -iname '*.go' -type f) # All the .go files, excluding vendor/
          UNFORMATTED=$(gofmt -s -l $GO_FILES)
          if [ -n "$UNFORMATTED" ]; then
            echo "The following files are not formatted:"
            echo "$UNFORMATTED"
            exit 1
          fi
      - name: Run go vet
        run: go vet ./...
      - name: Check code complexity
        run: |
          go install github.com/fzipp/gocyclo/cmd/gocyclo@latest
          /home/runner/go/bin/gocyclo -over 19 cmd pkg
      - name: Run unit tests
        run: |
          go test -v -race -timeout 5m -coverprofile=coverage.out -covermode=atomic -json ./pkg/... > test-results.json 2>&1 || true
          # Also run without JSON for readable output
          go test -v -race -timeout 5m -coverprofile=coverage.out -covermode=atomic ./pkg/...

      - name: Generate test report
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Go Tests
          path: test-results.json
          reporter: go-json
          fail-on-error: false

      - name: Generate coverage report
        run: |
          go tool cover -func=coverage.out > coverage-summary.txt
          go tool cover -html=coverage.out -o coverage.html
          echo "## ðŸ“Š Coverage Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          TOTAL=$(grep "total:" coverage-summary.txt | awk '{print $NF}')
          echo "**Total Coverage: ${TOTAL}**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "<details>" >> $GITHUB_STEP_SUMMARY
          echo "<summary>Detailed Coverage by Function</summary>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat coverage-summary.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "</details>" >> $GITHUB_STEP_SUMMARY

      - name: Upload test artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            coverage.out
            coverage.html
            coverage-summary.txt
            test-results.json
          retention-days: 14

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          files: ./coverage.out
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false

      - name: Post coverage summary as PR comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const coverageSummary = fs.readFileSync('coverage-summary.txt', 'utf8');
            const totalMatch = coverageSummary.match(/total:\s+\(statements\)\s+([\d.]+)%/);
            const totalCoverage = totalMatch ? totalMatch[1] : 'N/A';
            
            const body = `## ðŸ“Š Test Coverage Summary
            
            **Overall Coverage: ${totalCoverage}%**
            
            <details>
            <summary>Click to see detailed coverage</summary>
            
            \`\`\`
            ${coverageSummary}
            \`\`\`
            
            </details>
            
            ${parseFloat(totalCoverage) >= 50 ? 'âœ… Coverage meets minimum threshold (50%)' : 'âš ï¸ Coverage below minimum threshold (50%)'}
            `;
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('ðŸ“Š Test Coverage Summary')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
      - name: Build binary
        run: go build -o bin/helm-gcs ./cmd/helm-gcs/main.go
      - name: Verify binary
        run: ./bin/helm-gcs version
